<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cuber Timer Local</title>
    <!-- Tailwind CSS para el diseño -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React y Babel para procesar el código -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Iconos Lucide -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700;800&display=swap');
        body { font-family: 'ui-sans-serif', system-ui, -apple-system, sans-serif; }
        .font-mono { font-family: 'JetBrains Mono', monospace; }
        .custom-scrollbar::-webkit-scrollbar { width: 4px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #334155; border-radius: 10px; }
        .scramble-box { min-height: 120px; display: flex; align-items: center; justify-content: center; }
        /* Animación para el indicador de guardado */
        @keyframes fade-in-out {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        .sync-pulse { animation: fade-in-out 2s infinite; }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 overflow-x-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo } = React;

        const COLORS = {
            U: 'bg-white', D: 'bg-yellow-400', L: 'bg-orange-500', 
            R: 'bg-red-600', F: 'bg-green-500', B: 'bg-blue-600'
        };

        const App = () => {
            const [status, setStatus] = useState('IDLE');
            const [time, setTime] = useState(0);
            const [solves, setSolves] = useState([]);
            const [scramble, setScramble] = useState('');
            const [showPreview, setShowPreview] = useState(false);
            
            const timerRef = useRef(null);
            const startTimeRef = useRef(0);
            const holdTimeoutRef = useRef(null);

            // Cargar tiempos desde localStorage al iniciar
            useEffect(() => {
                const savedSolves = localStorage.getItem('cuber_solves');
                if (savedSolves) {
                    try {
                        setSolves(JSON.parse(savedSolves));
                    } catch (e) {
                        console.error("Error cargando historial local", e);
                    }
                }
            }, []);

            // Guardar tiempos en localStorage cuando cambie el historial
            useEffect(() => {
                localStorage.setItem('cuber_solves', JSON.stringify(solves));
            }, [solves]);

            const generateScramble = useCallback(() => {
                const faces = ['U', 'D', 'L', 'R', 'F', 'B'];
                const modifiers = ['', "'", '2'];
                let newScramble = [];
                let lastFace = '';
                for (let i = 0; i < 20; i++) {
                    let face;
                    do { face = faces[Math.floor(Math.random() * faces.length)]; } while (face === lastFace);
                    newScramble.push(face + modifiers[Math.floor(Math.random() * 3)]);
                    lastFace = face;
                }
                setScramble(newScramble.join(' '));
            }, []);

            useEffect(() => { generateScramble(); }, [generateScramble]);

            const cubeState = useMemo(() => {
                const cube = { U: Array(9).fill('U'), D: Array(9).fill('D'), L: Array(9).fill('L'), R: Array(9).fill('R'), F: Array(9).fill('F'), B: Array(9).fill('B') };
                const rotateFace = (f) => { const p = [...f]; f[0]=p[6]; f[1]=p[3]; f[2]=p[0]; f[3]=p[7]; f[4]=p[4]; f[5]=p[1]; f[6]=p[8]; f[7]=p[5]; f[8]=p[2]; };
                if (!scramble) return cube;
                scramble.split(' ').forEach(move => {
                    const f = move[0], m = move[1] || '', r = m === '2' ? 2 : m === "'" ? 3 : 1;
                    for(let i=0; i<r; i++) {
                        rotateFace(cube[f]);
                        let t;
                        if(f==='U'){ t=[cube.F[0],cube.F[1],cube.F[2]]; cube.F[0]=cube.R[0]; cube.F[1]=cube.R[1]; cube.F[2]=cube.R[2]; cube.R[0]=cube.B[0]; cube.R[1]=cube.B[1]; cube.R[2]=cube.B[2]; cube.B[0]=cube.L[0]; cube.B[1]=cube.L[1]; cube.B[2]=cube.L[2]; cube.L[0]=t[0]; cube.L[1]=t[1]; cube.L[2]=t[2]; }
                        if(f==='D'){ t=[cube.F[6],cube.F[7],cube.F[8]]; cube.F[6]=cube.L[6]; cube.F[7]=cube.L[7]; cube.F[8]=cube.L[8]; cube.L[6]=cube.B[6]; cube.L[7]=cube.B[7]; cube.L[8]=cube.B[8]; cube.B[6]=cube.R[6]; cube.B[7]=cube.R[7]; cube.B[8]=cube.R[8]; cube.R[6]=t[0]; cube.R[7]=t[1]; cube.R[8]=t[2]; }
                        if(f==='L'){ t=[cube.F[0],cube.F[3],cube.F[6]]; cube.F[0]=cube.U[0]; cube.F[3]=cube.U[3]; cube.F[6]=cube.U[6]; cube.U[0]=cube.B[8]; cube.U[3]=cube.B[5]; cube.U[6]=cube.B[2]; cube.B[8]=cube.D[0]; cube.B[5]=cube.D[3]; cube.B[2]=cube.D[6]; cube.D[0]=t[0]; cube.D[3]=t[1]; cube.D[6]=t[2]; }
                        if(f==='R'){ t=[cube.F[2],cube.F[5],cube.F[8]]; cube.F[2]=cube.D[2]; cube.F[5]=cube.D[5]; cube.F[8]=cube.D[8]; cube.D[2]=cube.B[6]; cube.D[5]=cube.B[3]; cube.D[8]=cube.B[0]; cube.B[6]=cube.U[2]; cube.B[3]=cube.U[5]; cube.B[0]=cube.U[8]; cube.U[2]=t[0]; cube.U[5]=t[1]; cube.U[8]=t[2]; }
                        if(f==='F'){ t=[cube.U[6],cube.U[7],cube.U[8]]; cube.U[6]=cube.L[8]; cube.U[7]=cube.L[5]; cube.U[8]=cube.L[2]; cube.L[8]=cube.D[2]; cube.L[5]=cube.D[1]; cube.L[2]=cube.D[0]; cube.D[2]=cube.R[0]; cube.D[1]=cube.R[3]; cube.D[0]=cube.R[6]; cube.R[0]=t[0]; cube.R[3]=t[1]; cube.R[6]=t[2]; }
                        if(f==='B'){ t=[cube.U[0],cube.U[1],cube.U[2]]; cube.U[0]=cube.R[2]; cube.U[1]=cube.R[5]; cube.U[2]=cube.R[8]; cube.R[2]=cube.D[8]; cube.R[5]=cube.D[7]; cube.R[8]=cube.D[6]; cube.D[8]=cube.L[6]; cube.D[7]=cube.L[3]; cube.D[6]=cube.L[0]; cube.L[6]=t[0]; cube.L[3]=t[1]; cube.L[0]=t[2]; }
                    }
                });
                return cube;
            }, [scramble]);

            const formatTime = (ms) => {
                const m = Math.floor(ms / 60000), s = Math.floor((ms % 60000) / 1000), c = Math.floor((ms % 1000) / 10);
                return `${m > 0 ? m + ':' : ''}${s.toString().padStart(m > 0 ? 2 : 1, '0')}.${c.toString().padStart(2, '0')}`;
            };

            const startTimer = useCallback(() => { 
                startTimeRef.current = Date.now(); 
                setStatus('RUNNING'); 
                setShowPreview(false); 
                timerRef.current = setInterval(() => setTime(Date.now() - startTimeRef.current), 10); 
            }, []);

            const stopTimer = useCallback(() => {
                clearInterval(timerRef.current);
                const finalTime = Date.now() - startTimeRef.current;
                setTime(finalTime);
                setStatus('STOPPED');
                
                const newSolve = {
                    id: Date.now(),
                    time: finalTime,
                    date: new Date().toLocaleTimeString(),
                    timestamp: Date.now(),
                    scramble: scramble
                };
                
                setSolves(prev => [newSolve, ...prev]);
                generateScramble();
            }, [scramble, generateScramble]);

            useEffect(() => {
                const handleKD = (e) => {
                    if (e.repeat) return;
                    if (status === 'RUNNING') { stopTimer(); return; }
                    if (e.code === 'Space' && (status === 'IDLE' || status === 'STOPPED')) {
                        setStatus('PRESSING');
                        holdTimeoutRef.current = setTimeout(() => setStatus('READY'), 1000);
                    }
                };
                const handleKU = (e) => {
                    if (e.code === 'Space') {
                        if (status === 'READY') startTimer();
                        else if (status === 'PRESSING') { clearTimeout(holdTimeoutRef.current); setStatus('IDLE'); }
                    }
                    if (status === 'RUNNING' && e.code !== 'Space') { stopTimer(); }
                };
                window.addEventListener('keydown', handleKD); window.addEventListener('keyup', handleKU);
                return () => { window.removeEventListener('keydown', handleKD); window.removeEventListener('keyup', handleKU); };
            }, [status, startTimer, stopTimer]);

            const FaceGrid = ({ stickers }) => (
                <div className="grid grid-cols-3 gap-0.5 bg-slate-900 border border-slate-900 w-10 h-10 md:w-14 md:h-14">
                    {stickers.map((s, i) => <div key={i} className={`w-full h-full rounded-sm ${COLORS[s]}`} />)}
                </div>
            );

            const deleteSolve = (id) => {
                setSolves(prev => prev.filter(s => s.id !== id));
            };

            const ao5 = useMemo(() => {
                if (solves.length < 5) return null;
                const last5 = solves.slice(0, 5).map(s => s.time);
                // WCA Style: Quitar el mejor y el peor y hacer media del resto
                const sorted = [...last5].sort((a, b) => a - b);
                const middle3 = sorted.slice(1, 4);
                return middle3.reduce((a, b) => a + b, 0) / 3;
            }, [solves]);

            return (
                <div className="min-h-screen p-4 md:p-8 flex flex-col items-center relative overflow-hidden font-sans bg-slate-900 text-slate-100">
                    
                    {/* Panel de Previsualización */}
                    <div className={`fixed top-0 right-0 h-full w-80 bg-slate-800 border-l border-slate-700 shadow-2xl transition-all duration-300 z-50 p-6 flex flex-col ${showPreview ? 'translate-x-0 opacity-100 visible' : 'translate-x-full opacity-0 invisible'}`}>
                        <div className="flex justify-between items-center mb-8">
                            <h3 className="text-xl font-bold flex items-center gap-2 text-blue-400"><i data-lucide="eye" className="w-5 h-5"></i> Cubo</h3>
                            <button onClick={() => setShowPreview(false)} className="p-2 hover:bg-slate-700 rounded-lg transition-colors"><i data-lucide="x" className="w-6 h-6"></i></button>
                        </div>
                        <div className="flex-1 flex flex-col items-center justify-center space-y-4">
                            <div className="relative inline-block">
                                <div className="flex justify-center mb-1"><FaceGrid stickers={cubeState.U} /></div>
                                <div className="flex gap-1"><FaceGrid stickers={cubeState.L} /><FaceGrid stickers={cubeState.F} /><FaceGrid stickers={cubeState.R} /><FaceGrid stickers={cubeState.B} /></div>
                                <div className="flex justify-center mt-1"><FaceGrid stickers={cubeState.D} /></div>
                            </div>
                            <div className="mt-8 bg-slate-900/50 p-4 rounded-xl border border-slate-700 w-full text-center">
                                <p className="text-[10px] text-slate-500 uppercase font-black tracking-widest mb-2">Mezcla Actual</p>
                                <p className="font-mono text-[10px] text-slate-300 break-words">{scramble}</p>
                            </div>
                        </div>
                    </div>

                    {/* Botón Lateral (Ojo) */}
                    {status !== 'RUNNING' && (
                        <button onClick={() => setShowPreview(true)} className={`fixed right-0 top-1/2 -translate-y-1/2 bg-blue-600 hover:bg-blue-500 text-white h-14 rounded-l-2xl shadow-xl transition-all z-40 group flex items-center overflow-hidden ${showPreview ? 'opacity-0 translate-x-10' : 'opacity-100 translate-x-0'}`}>
                            <div className="w-14 h-14 flex items-center justify-center shrink-0"><i data-lucide="eye" className="w-5 h-5"></i></div>
                            <span className="max-w-0 opacity-0 group-hover:max-w-xs group-hover:opacity-100 group-hover:pr-6 transition-all duration-300 whitespace-nowrap overflow-hidden text-xs font-black uppercase tracking-widest">Ver Cubo</span>
                        </button>
                    )}

                    {/* Header */}
                    <div className="w-full max-w-4xl flex justify-between items-center mb-8">
                        <div className="flex items-center gap-2">
                            <div className="bg-blue-600 p-2 rounded-lg shadow-lg shadow-blue-500/20"><i data-lucide="timer" className="w-6 h-6 text-white"></i></div>
                            <div>
                                <h1 className="text-2xl font-black uppercase tracking-tight leading-none">Cuber Timer</h1>
                                <p className="text-[9px] text-blue-400 font-bold tracking-widest uppercase mt-1 flex items-center gap-1">
                                    <span className="w-1.5 h-1.5 bg-blue-400 rounded-full sync-pulse"></span>
                                    Guardado Local
                                </p>
                            </div>
                        </div>
                        <div className="bg-slate-800 px-4 py-2 rounded-xl border border-slate-700">
                            <p className="text-[10px] text-slate-500 uppercase font-black tracking-widest">PB</p>
                            <p className="text-xl font-mono text-yellow-400 leading-none">{solves.length > 0 ? formatTime(Math.min(...solves.map(s => s.time))) : "--"}</p>
                        </div>
                    </div>

                    {/* Scramble Display */}
                    <div className={`w-full max-w-2xl mb-8 transition-all duration-500 ${status === 'RUNNING' ? 'opacity-0 -translate-y-4' : 'opacity-100'}`}>
                        <div className="bg-slate-800/40 rounded-3xl border border-slate-700/50 overflow-hidden">
                            <div className="flex justify-between items-center px-6 py-2 bg-slate-700/30 border-b border-slate-700/50">
                                <span className="text-[9px] uppercase tracking-[0.3em] font-black text-slate-500">Mezcla 3x3</span>
                                <button onClick={generateScramble} className="p-1.5 text-slate-400 hover:text-blue-400 transition-colors"><i data-lucide="refresh-cw" className="w-4 h-4"></i></button>
                            </div>
                            <div className="p-8 scramble-box">
                                <p className="text-center text-xl md:text-2xl font-mono tracking-widest text-slate-100 leading-relaxed uppercase">{scramble}</p>
                            </div>
                        </div>
                    </div>

                    {/* Timer Principal */}
                    <div className="flex-1 flex flex-col items-center justify-center w-full mb-12 select-none">
                        <div className={`transition-all duration-200 transform ${status === 'PRESSING' ? 'text-red-500 scale-95' : status === 'READY' ? 'text-green-500 font-bold scale-110 drop-shadow-[0_0_20px_rgba(34,197,94,0.4)]' : status === 'RUNNING' ? 'text-white' : 'text-blue-400'}`}>
                            <div className="text-8xl md:text-[10rem] font-mono tabular-nums tracking-tighter leading-none">{formatTime(time)}</div>
                        </div>
                        <div className="mt-12 bg-slate-800/80 px-8 py-4 rounded-full border border-slate-700/50 text-[10px] uppercase font-black tracking-widest text-slate-400 shadow-xl backdrop-blur-sm">
                            {status === 'IDLE' || status === 'STOPPED' ? 'Mantén ESPACIO 1s para empezar' : status === 'PRESSING' ? 'Preparando...' : status === 'READY' ? '¡SUELTA YA!' : 'Pulsa CUALQUIER TECLA para parar'}
                        </div>
                    </div>

                    {/* Historial y AO5 */}
                    <div className="w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-6 pb-4">
                        <div className="bg-slate-800/50 rounded-3xl p-6 border border-slate-700 flex flex-col">
                            <h2 className="text-xs font-black uppercase text-blue-400 mb-4 flex items-center gap-2"><i data-lucide="history" className="w-4 h-4"></i> Historial Local</h2>
                            <div className="max-h-40 overflow-y-auto space-y-2 pr-2 custom-scrollbar">
                                {solves.map(s => (
                                    <div key={s.id} className="bg-slate-700/20 p-3 rounded-xl flex justify-between items-center group hover:bg-slate-700/40 transition-colors">
                                        <span className="text-lg font-mono font-bold">{formatTime(s.time)}</span>
                                        <div className="flex items-center gap-3">
                                            <span className="text-[10px] text-slate-500">{s.date}</span>
                                            <button onClick={() => deleteSolve(s.id)} className="text-slate-600 hover:text-red-500 p-1"><i data-lucide="trash-2" className="w-3.5 h-3.5"></i></button>
                                        </div>
                                    </div>
                                ))}
                                {solves.length === 0 && <p className="text-slate-600 text-xs italic text-center py-4">No hay tiempos registrados</p>}
                            </div>
                        </div>
                        <div className="bg-gradient-to-br from-blue-700 to-indigo-900 rounded-3xl p-6 text-white border border-white/10 flex items-center justify-around shadow-2xl relative overflow-hidden">
                            <div className="absolute top-0 right-0 p-4 opacity-5 pointer-events-none"><i data-lucide="trophy" className="w-24 h-24"></i></div>
                            <div className="text-center relative z-10">
                                <p className="text-[10px] uppercase font-black opacity-60 mb-1 tracking-widest">Media (AO5)</p>
                                <p className="text-3xl font-mono font-bold">{ao5 ? formatTime(ao5) : "--"}</p>
                            </div>
                            <div className="text-center relative z-10">
                                <p className="text-[10px] uppercase font-black opacity-60 mb-1 tracking-widest">Mejor Tiempo</p>
                                <p className="text-3xl font-mono font-bold text-yellow-400">{solves.length > 0 ? formatTime(Math.min(...solves.map(s=>s.time))) : "--"}</p>
                            </div>
                        </div>
                    </div>

                    {/* Crédito Final */}
                    <div className="mt-8 mb-4 text-[10px] text-slate-600 font-bold uppercase tracking-[0.3em] opacity-50 hover:opacity-100 transition-opacity flex items-center gap-2">
                        <span className="w-4 h-[1px] bg-slate-700"></span>
                        Hecho por Nicolaxito
                        <span className="w-4 h-[1px] bg-slate-700"></span>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);

        const updateIcons = () => { if (window.lucide) { window.lucide.createIcons(); } };
        setTimeout(updateIcons, 500);
        setInterval(updateIcons, 3000);
    </script>
</body>
</html>
